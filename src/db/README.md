# Database Layer

This directory contains the database layer for Mission Control backend.

## Files

- **`schema.sql`** - Complete database schema (tables, indexes, triggers, views)
- **`client.ts`** - Database connection pool and query wrapper
- **`migrate.ts`** - Migration runner for schema changes
- **`types.ts`** - TypeScript type definitions matching the schema
- **`migrations/`** - Incremental schema migrations

## Quick Start

### 1. Set up PostgreSQL

Ensure PostgreSQL 14+ is running and create the database:

```bash
# Using psql
createdb mission_control

# Or with docker-compose (included in project root)
cd mission-control-backend
docker-compose up -d postgres
```

### 2. Configure environment

Copy `.env.example` to `.env` and update database credentials:

```env
POSTGRES_HOST=localhost
POSTGRES_PORT=5432
POSTGRES_DB=mission_control
POSTGRES_USER=mission_control
POSTGRES_PASSWORD=your-secure-password
```

### 3. Initialize the database

Run the initial schema:

```bash
npm run db:migrate init
```

This will:
- Create all tables, indexes, triggers, and views
- Insert seed data (provider pricing)
- Record the schema as migration version 0

### 4. Verify the setup

```bash
npm run db:migrate status
```

Should show:
```
âœ“ Applied | Version 0 | initial_schema
```

## Usage in Code

### Basic Queries

```typescript
import { db } from './db/client';

// Connect (usually done in server startup)
await db.connect();

// Query all rows
const hosts = await db.queryMany<Host>('SELECT * FROM hosts WHERE status = $1', ['online']);

// Query single row
const host = await db.queryOne<Host>('SELECT * FROM hosts WHERE id = $1', [hostId]);

// Insert
const result = await db.query(
  'INSERT INTO hosts (name, type, cluster, addresses) VALUES ($1, $2, $3, $4) RETURNING *',
  ['pedro', 'k8s-node', 'k8s-prod', { lan: '192.168.50.20' }]
);

// Health check
const healthy = await db.healthCheck();
```

### Transactions

```typescript
import { db } from './db/client';

const result = await db.transaction(async (client) => {
  // Create a task
  const task = await client.query(
    'INSERT INTO tasks (title, created_by) VALUES ($1, $2) RETURNING *',
    ['Restart Plex', 'system']
  );

  // Create a task run
  const run = await client.query(
    'INSERT INTO task_runs (task_id, user_prompt, status) VALUES ($1, $2, $3) RETURNING *',
    [task.rows[0].id, 'Restart Plex and verify health', 'queued']
  );

  return { task: task.rows[0], run: run.rows[0] };
});
```

### Type Safety

Use the exported types for type safety:

```typescript
import { Host, Workload, TaskRun } from './db/types';

const hosts = await db.queryMany<Host>('SELECT * FROM hosts');
// hosts is typed as Host[]

const workload = await db.queryOne<Workload>(
  'SELECT * FROM workloads WHERE id = $1',
  [workloadId]
);
// workload is typed as Workload | null
```

## Schema Overview

### Inventory Tables
- **`hosts`** - Physical/virtual machines, K8s nodes, containers
- **`workloads`** - Deployments, pods, VMs, LXCs, containers
- **`services`** - Logical groupings of workloads

### Task Execution Tables
- **`tasks`** - Task templates or one-off definitions
- **`task_runs`** - Execution instances of tasks
- **`task_events`** - Append-only log of task execution events
- **`artifacts`** - Files/outputs generated by tasks

### LLM Tracking Tables
- **`llm_requests`** - LLM API requests
- **`llm_responses`** - LLM API responses
- **`token_usage`** - Token usage and cost tracking
- **`provider_pricing`** - Pricing configuration for providers

### Tools & Policy Tables
- **`tool_definitions`** - Available tools and their schemas
- **`tool_call_records`** - History of tool executions
- **`policies`** - Approval policies

### Audit
- **`audit_entries`** - Immutable audit log for all system actions

## Views

Convenience views for common queries:

- **`active_task_runs`** - All non-completed task runs
- **`recent_token_usage_summary`** - Token usage by provider/model (last 30 days)
- **`tool_call_success_rate`** - Tool success rates and avg duration

Usage:
```typescript
const activeRuns = await db.queryMany('SELECT * FROM active_task_runs');
const usageSummary = await db.queryMany('SELECT * FROM recent_token_usage_summary');
```

## Migrations

See [`migrations/README.md`](./migrations/README.md) for details on creating and applying migrations.

Common commands:
```bash
# Check status
npm run db:migrate status

# Apply pending migrations
npm run db:migrate

# Initialize fresh database
npm run db:migrate init
```

## Connection Pool

The database client uses a connection pool with these defaults:
- **Max connections**: 20
- **Idle timeout**: 30 seconds
- **Connection timeout**: 10 seconds

Get pool statistics:
```typescript
const stats = db.getPoolStats();
// { total: 5, idle: 3, waiting: 0 }
```

## Best Practices

1. **Always use parameterized queries** to prevent SQL injection:
   ```typescript
   // Good
   await db.query('SELECT * FROM hosts WHERE name = $1', [name]);

   // Bad (vulnerable to injection)
   await db.query(`SELECT * FROM hosts WHERE name = '${name}'`);
   ```

2. **Use transactions for multi-step operations**:
   ```typescript
   await db.transaction(async (client) => {
     await client.query('INSERT INTO tasks ...');
     await client.query('INSERT INTO task_runs ...');
   });
   ```

3. **Close the pool on shutdown**:
   ```typescript
   process.on('SIGTERM', async () => {
     await db.disconnect();
     process.exit(0);
   });
   ```

4. **Use the health check** in your health endpoint:
   ```typescript
   app.get('/health', async (req, res) => {
     const dbHealthy = await db.healthCheck();
     res.json({ status: dbHealthy ? 'healthy' : 'degraded' });
   });
   ```

## Troubleshooting

### Connection errors
If you see "Database pool not initialized", ensure you call `await db.connect()` before making queries.

### Migration errors
If a migration fails, it will automatically rollback. Check logs for details and fix the SQL before retrying.

### Type mismatches
Ensure your TypeScript types in `types.ts` match the database schema. Run type checking with `npm run typecheck`.

### Performance issues
- Check pool statistics with `db.getPoolStats()`
- Review slow queries in logs (queries > 1s are logged at WARN level)
- Add indexes for frequently queried columns
